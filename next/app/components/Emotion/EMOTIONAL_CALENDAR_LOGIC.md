# Логика работы EmotionalCalendar.tsx

## Обзор компонента

`EmotionalCalendar.tsx` - это компонент React, который отображает эмоциональный календарь прослушиваний пользователя в виде визуализации GitHub Contributions-style. Компонент показывает настроение пользователя по дням на основе проанализированных треков.

## Текущая архитектура

### 1. Источник данных

**Текущий подход:** Данные загружаются напрямую из Last.fm API через endpoint `/api/lastfm/user/mood-history`

**Процесс загрузки:**
- Компонент использует `useUserStore` из Zustand store
- При монтировании автоматически вызывается `loadMoodHistory()` если данных нет
- Данные запрашиваются через `GET /api/lastfm/user/mood-history?days=90`

### 2. Структура данных

Компонент ожидает массив `ListeningDay[]` со следующей структурой:

```typescript
interface ListeningDay {
  date: string;        // Формат: "YYYY-MM-DD"
  tracks: number;      // Количество треков за день
  mood: Mood;          // Доминирующее настроение: 'joy' | 'energy' | 'calm' | 'sad' | 'love'
  intensity: number;   // Интенсивность настроения (0-1)
}
```

### 3. Логика отображения календаря

#### 3.1 Формирование календарной сетки (`calendarData`)

```typescript
const calendarData = useMemo(() => {
  // Преобразует массив дней в недели (7 дней)
  // Добавляет пустые ячейки для выравнивания по понедельнику
  // Возвращает массив недель, каждая неделя - массив из 7 дней
}, [listeningHistory]);
```

**Алгоритм:**
1. Определяет первый день в истории
2. Вычисляет отступ для выравнивания по понедельнику: `(firstDate.getDay() + 6) % 7`
3. Заполняет пустые ячейки до начала недели
4. Группирует дни по неделям (по 7 дней)
5. Дополняет последнюю неделю пустыми ячейками до 7 дней

#### 3.2 Статистика настроений (`moodStats`)

```typescript
const moodStats = useMemo(() => {
  // Подсчитывает количество дней для каждого настроения
  // Вычисляет процентное соотношение
  // Сортирует по убыванию количества
}, [listeningHistory]);
```

**Результат:** Массив объектов с полями:
- `mood`: тип настроения
- `count`: количество дней
- `percentage`: процент от общего количества дней

### 4. Визуализация

#### 4.1 Календарная сетка
- Каждый день представлен квадратом 3x3px
- Цвет зависит от настроения (`moodColors`)
- Прозрачность зависит от интенсивности: `opacity = 0.3 + intensity * 0.7`
- Пустые дни (без данных) имеют серый цвет с низкой прозрачностью

#### 4.2 Цветовая схема настроений

```typescript
const moodColors = {
  joy: 'bg-emotion-joy',      // Радость
  energy: 'bg-emotion-energy', // Энергия
  calm: 'bg-emotion-calm',     // Спокойствие
  sad: 'bg-emotion-sad',       // Меланхолия
  love: 'bg-emotion-love',     // Любовь
};
```

#### 4.3 Боковая панель статистики
- Показывает распределение эмоций в процентах
- Отображает прогресс-бары для каждого настроения
- Показывает общее количество треков за период

### 5. Обработка состояний

#### 5.1 Загрузка (`isLoadingMoodHistory`)
- Показывает сообщение "Загрузка эмоционального календаря..."
- Блокирует кнопку обновления

#### 5.2 Ошибка (`moodHistoryError`)
- Отображает сообщение об ошибке
- Предлагает кнопку "Попробовать снова"

#### 5.3 Пустые данные
- Если `listeningHistory.length === 0`, календарь пустой
- Статистика не отображается

## Текущий API endpoint: `/api/lastfm/user/mood-history`

### Логика работы endpoint:

1. **Получение данных из Last.fm:**
   - Запрашивает `user.getRecentTracks` с параметрами `from` и `to` (timestamps)
   - Ограничивает до 5 страниц (максимум 1000 треков)
   - Получает все скробблы за указанный период (по умолчанию 90 дней)

2. **Группировка по дням:**
   - Создает Map с ключом = дата (YYYY-MM-DD)
   - Подсчитывает количество треков за каждый день
   - Собирает уникальные треки для анализа

3. **Анализ настроения:**
   - Для каждого уникального трека вызывает `analyzeTrackMood(artist, track)`
   - Ограничивает анализ до 100 уникальных треков
   - Обрабатывает батчами по 10 треков с задержкой 500ms между батчами
   - Использует Last.fm API для получения тегов трека
   - Маппит теги на настроения через `tagToMood` словарь

4. **Определение доминирующего настроения:**
   - Для каждого дня суммирует счетчики настроений всех треков
   - Выбирает настроение с максимальным счетчиком
   - Вычисляет интенсивность: `Math.min(tracks / 20, 1)`

5. **Возврат результата:**
   - Возвращает отсортированный массив `ListeningDay[]`

### Проблемы текущего подхода:

1. **Медленная загрузка:** Каждый запрос требует множественных вызовов Last.fm API
2. **Лимиты API:** Last.fm имеет ограничения на количество запросов
3. **Дублирование работы:** Анализ настроений повторяется при каждом запросе
4. **Зависимость от внешнего сервиса:** При недоступности Last.fm данные не загружаются

## Использование истории из базы данных

### Доступные данные в БД

В базе данных есть таблица `RecentTracks` со следующей структурой:

```javascript
{
  id: INTEGER,
  userId: INTEGER,        // Связь с пользователем
  trackId: INTEGER,       // Связь с треком
  playedAt: DATE,         // Время прослушивания
  createdAt: DATE,
  updatedAt: DATE
}
```

**Связанные таблицы:**
- `Tracks` - содержит информацию о треке (name, artistId, albumId, etc.)
- `Artists` - содержит информацию об артисте (name, mbid, url)
- `Albums` - содержит информацию об альбоме (title, mbid, image)

### Существующие API endpoints

**Backend (Express):**
- `GET /api/music/users/:userId/recent-tracks?limit=50&offset=0`
  - Возвращает треки из БД с полной информацией (track, artist, album)
  - Уже используется в компоненте `TraksUser.tsx`

**Frontend (Next.js):**
- `GET /api/sync/recent-tracks` - синхронизирует данные из Last.fm в БД

### Преимущества использования БД

1. **Быстрота:** Данные уже в БД, не нужно запрашивать Last.fm API
2. **Надежность:** Не зависит от доступности внешнего сервиса
3. **Кэширование анализа:** Можно сохранять результаты анализа настроений
4. **Гибкость:** Можно фильтровать по датам, группировать, агрегировать на уровне БД

### Предлагаемая реализация

#### Вариант 1: Новый API endpoint на основе БД

Создать новый endpoint `/api/database/user/mood-history`:

```typescript
// next/app/api/database/user/mood-history/route.ts

export async function GET(request: Request) {
  // 1. Получить userId из cookies/session
  // 2. Запросить RecentTracks из БД за последние N дней
  // 3. Группировать по дням (playedAt)
  // 4. Для каждого дня:
  //    - Подсчитать количество треков
  //    - Проанализировать настроения (можно кэшировать результаты)
  //    - Определить доминирующее настроение
  // 5. Вернуть ListeningDay[]
}
```

**Преимущества:**
- Использует существующие данные в БД
- Можно добавить кэширование результатов анализа
- Быстрее, чем запросы к Last.fm

**Недостатки:**
- Нужно убедиться, что БД синхронизирована с Last.fm
- Если БД пустая, нужно будет использовать Last.fm как fallback

#### Вариант 2: Гибридный подход

```typescript
export async function GET(request: Request) {
  // 1. Попытаться получить данные из БД
  // 2. Если данных достаточно (например, за последние 90 дней) - использовать их
  // 3. Если данных мало или они устарели - дополнить из Last.fm
  // 4. Объединить результаты
}
```

**Преимущества:**
- Надежность: всегда есть данные
- Оптимизация: использует БД когда возможно
- Актуальность: дополняет из Last.fm при необходимости

#### Вариант 3: Кэширование анализа настроений

Создать таблицу для кэширования результатов анализа:

```sql
CREATE TABLE TrackMoodAnalysis (
  trackId INTEGER,
  artistName VARCHAR(255),
  trackName VARCHAR(255),
  moodCounts JSON,  -- {joy: 2, energy: 1, calm: 0, sad: 0, love: 1}
  analyzedAt DATE,
  PRIMARY KEY (trackId, artistName, trackName)
);
```

**Преимущества:**
- Анализ выполняется один раз для каждого трека
- Последующие запросы используют кэш
- Значительно ускоряет формирование календаря

### Рекомендации по реализации

1. **Создать новый endpoint** `/api/database/user/mood-history`:
   - Использовать существующий Express API для получения RecentTracks
   - Группировать по дням на уровне Next.js API
   - Анализировать настроения с использованием существующего `moodAnalyzer.ts`

2. **Добавить кэширование:**
   - Сохранять результаты анализа настроений в БД или Redis
   - Использовать кэш при повторных запросах

3. **Обновить компонент:**
   - Добавить возможность выбора источника данных (Last.fm или БД)
   - Или автоматически использовать БД с fallback на Last.fm

4. **Синхронизация:**
   - Убедиться, что данные регулярно синхронизируются из Last.fm
   - Можно использовать существующий endpoint `/api/sync/recent-tracks`

### Пример запроса к БД

```javascript
// В Express API можно добавить метод:
async getUserRecentTracksByDateRange(userId, startDate, endDate) {
  return this.RecentTrack.findAndCountAll({
    where: {
      userId,
      playedAt: {
        [Op.between]: [startDate, endDate]
      }
    },
    include: [
      {
        model: this.Track,
        as: 'track',
        include: [
          { model: this.Artist, as: 'artist' },
          { model: this.Album, as: 'album' },
        ],
      },
    ],
    order: [['playedAt', 'ASC']],
  });
}
```

## Заключение

Текущая реализация работает, но имеет ограничения по производительности и зависимости от внешнего API. Использование данных из БД позволит:

- Ускорить загрузку календаря
- Снизить нагрузку на Last.fm API
- Повысить надежность приложения
- Добавить возможность кэширования и оптимизации

Рекомендуется реализовать гибридный подход с приоритетом на данные из БД и fallback на Last.fm API при необходимости.
